<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dino Game</title>
</head>

<body>
    <canvas id="game" width="800px" height="200px" style="border: 1px solid black;"></canvas>
    <button id="resetBtn" onclick="game.restart()" disabled>Restart</button>

    <script>
        class Obstacle {
            constructor(x, width, height) {
                this.x = x;
                this.dx = 5;
                this.width = width;
                this.height = height;
            }

            render(ctx) {
                ctx.fillRect(this.x, 0, this.width, this.height);
            }

            move() {
                this.x -= this.dx;
            }

            isPointInside(x, y) {
                if (y <= this.height && x >= this.x && x <= (this.x + this.width)) {
                    return true;
                }
                return false;
            }
        }

        class Game {
            constructor(canvas) {
                this.gameIsRunning = true;
                this.isJumping = false;

                this.dinoX = 50;
                this.dinoY = 0;
                this.dinoWidth = 20;
                this.dinoHeight = 50;

                this.obstacles = [new Obstacle(800, 20, 25), new Obstacle(1000, 20, 25), new Obstacle(1200, 20, 25)];

                this.restartBtn = document.getElementById('resetBtn');
                this.ctx = canvas.getContext('2d');
                this.ctx.translate(0, canvas.height);
                this.ctx.scale(1, -1);

                setInterval(() => {
                    if (this.gameIsRunning) {
                        this.ctx.clearRect(0, 0, canvas.width, canvas.height);
                        this.ctx.fillRect(this.dinoX, this.dinoY, this.dinoWidth, this.dinoHeight);

                        this.obstacles.forEach(obstacle => obstacle.render(this.ctx));

                        this.obstacles.forEach(obstacle => {
                            if (obstacle.isPointInside(0 - obstacle.width, 0)) {
                                this.obstacles.splice(this.obstacles.indexOf(obstacle), 1);
                                return;
                            }

                            if (obstacle.isPointInside(this.dinoX, this.dinoY) || obstacle.isPointInside(this.dinoX + this.dinoWidth, this.dinoY)) {
                                alert('Game over');
                                this.gameIsRunning = false;
                                this.restartBtn.disabled = false;
                            }

                            obstacle.move();
                        });
                    }
                }, 1000 / 60);

                window.addEventListener('keydown', (evt) => {
                    if (evt.code === JUMP_KEY) {
                        this.jump();
                    }
                });
            }

            jump() {
                if (!this.isJumping) {
                    this.isJumping = true;
                    this.dinoY = 50;
                    setTimeout(() => {
                        this.dinoY = 0;
                        this.isJumping = false;
                    }, JUMP_DURATION);
                }
            }

            restart() {
                this.gameIsRunning = true;
                this.restartBtn.disabled = true;
            }
        }

        const JUMP_KEY = 'Space';
        const JUMP_DURATION = 333;

        const canvas = document.getElementById('game');

        const game = new Game(canvas);
    </script>
</body>

</html>